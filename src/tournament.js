console.log("‚úÖ tournament.js za≈Çadowany");

import { updateElo, getEloDelta } from './utils/elo.js';
import { validateResult, updateStats } from './utils/stats.js';
import { generateRoundRobinRounds, generateMatchesForSeries } from './utils/pairing.js';
import { saveData, saveDraft } from './utils/firebaseSync.js';
import { db, doc, getDoc, deleteDoc, auth } from '../firebase.js';

// ‚îÄ‚îÄ‚îÄ Funkcja do aktualizacji serii zwyciƒôstw/pora≈ºek ‚îÄ‚îÄ‚îÄ
function updateStreak(playerName, won) {
  // Pobierz istniejƒÖce statystyki lub utw√≥rz nowe
  const gs = generalStats[playerName] ||= { wins:0, losses:0, pointsScored:0, pointsConceded:0, obecnosc:0 };
  // Je≈õli jeszcze nie by≈Ço serii, ustaw jƒÖ na 1W lub 1L
  if (!gs.streakType) {
    gs.streakType = won ? "W" : "L";
    gs.streakCount = 1;
  }
  // Je≈õli ten sam typ serii co poprzednio, zwiƒôksz licznik
  else if ((won && gs.streakType === "W") || (!won && gs.streakType === "L")) {
    gs.streakCount++;
  }
  // Inaczej zacznij seriƒô od nowa
  else {
    gs.streakType = won ? "W" : "L";
    gs.streakCount = 1;
  }
}





// ======= GLOBALNE ZMIENNE TURNIEJU =======
export let allPlayers = [];
let nextPlayerId = 1;
let players = [];
export let matches = [];
let results = [];
export let stats = {};
export let generalStats = {};
window.tournamentEnded = false;


export let allMatches = [];


// Zmienne do rund (round-robin)
let allRounds = [];
let currentRoundIndex = 0;


// ======= FUNKCJA ≈ÅADUJƒÑCA CZCIONKƒò (DO GENEROWANIA PDF) =======
function loadCustomFont(doc) {
  doc.addFileToVFS("DejaVuSans.ttf", "YOUR_BASE64_FONT_STRING");
  doc.addFont("DejaVuSans.ttf", "DejaVuSans", "normal");
  doc.setFont("DejaVuSans");
}

// ======= DODAWANIE NOWEGO GRACZA =======
export function addPlayer() {
  if (tournamentEnded) return;
  const nameInput = document.getElementById("newPlayerName");
  const name = nameInput.value.trim();
  if (!name) {
    alert("Podaj nazwƒô gracza!");
    return;
  }
  if (allPlayers.some(p => p.name.toLowerCase() === name.toLowerCase())) {
    alert("Gracz o takiej nazwie ju≈º istnieje!");
    return;
  }
  const newPlayer = { id: nextPlayerId++, name: name, elo: 1000 };
  allPlayers.push(newPlayer);
  nameInput.value = "";
  window.renderPlayersList();
}

// ======= POTWIERDZENIE WYBORU GRACZY =======
export async function confirmPlayers() {
  if (tournamentEnded) return;

  const checkboxes = document.querySelectorAll(".playerCheckbox");
  allPlayers.forEach(p => p.selected = false);

  const selected = [];

  checkboxes.forEach(chk => {
    if (chk.checked) {
      const playerId = parseInt(chk.value);
      const player = allPlayers.find(p => p.id === playerId);
      if (player) {
        player.selected = true;
        selected.push(player.name);
      }
    }
  });

  const players = allPlayers.filter(p => p.selected);
  if (players.length < 2) {
    alert("Wybierz co najmniej dw√≥ch graczy, aby wygenerowaƒá mecze.");
    return;
  }

  const courtCount = parseInt(document.getElementById("numCourts").value, 10) || 1;

  // ‚ö†Ô∏è Sprawdzenie minimalnej liczby graczy wzglƒôdem kort√≥w
  if (players.length < courtCount * 2) {
    alert(`Za ma≈Ço graczy na ${courtCount} kort${courtCount > 1 ? 'y' : ''}!\nPotrzebujesz co najmniej ${courtCount * 2} graczy.`);
    return;
  }


  players.forEach(player => {
    stats[player.name] = stats[player.name] || { wins: 0, losses: 0, pointsScored: 0, pointsConceded: 0 };
    generalStats[player.name] = generalStats[player.name] || { wins: 0, losses: 0, pointsScored: 0, pointsConceded: 0, obecnosc: 0 };
  });


  alert("Gracze zostali wybrani. Mo≈ºesz teraz wygenerowaƒá mecze.");
  await saveData(generalStats, allPlayers);

}


// ======= POTWIERDZANIE MECZU =======
// ======= POTWIERDZANIE MECZU =======
export async function confirmMatch(index) {
  if (tournamentEnded) {
    alert("Turniej zosta≈Ç zako≈Ñczony. Nie mo≈ºna wpisywaƒá wynik√≥w.");
    return;
  }

  const match = matches[index];
  const input1 = document.getElementById(`score1-${index}`);
  const input2 = document.getElementById(`score2-${index}`);

  const score1 = parseInt(input1.value, 10);
  const score2 = parseInt(input2.value, 10);

  if (isNaN(score1) || isNaN(score2) || score1 < 0 || score2 < 0) {
    alert("Wprowad≈∫ nieujemne liczby dla obu graczy.");
    return;
  }

  if (!validateResult(score1, score2)) {
    alert(
      "Wynik meczu jest niepoprawny. Zasady:\n" +
      "‚Ä¢ Zwyciƒôzca: 11 pkt, je≈õli przeciwnik ma <10\n" +
      "‚Ä¢ Lub r√≥≈ºnica 2 pkt przy 10+"
    );
    return;
  }

  const result = `${score1}:${score2}`;
  const winner = score1 > score2 ? match.player1 : match.player2;

  const p1 = allPlayers.find(p => p.name === match.player1);
  const p2 = allPlayers.find(p => p.name === match.player2);

  // üìä Oblicz delty ‚Äûna sucho‚Äù
  const elo1Before = p1?.elo ?? 1000;
  const elo2Before = p2?.elo ?? 1000;
  const [delta1, delta2, marginFactor] = getEloDelta(p1, p2, score1, score2);

  // ‚îÄ‚îÄ‚îÄ Przygotowanie modala ‚îÄ‚îÄ‚îÄ
  const modalContent = document.getElementById("matchConfirmContent");
  const streak1 = getStreakLabel(p1);
  const streak2 = getStreakLabel(p2);
  modalContent.innerHTML = `
    <p><strong>${match.player1}:</strong> ${score1} pkt${streak1}<br/>
       ELO: ${elo1Before} ‚Üí ${elo1Before + delta1}
       <span class="text-muted">(zmiana: ${delta1 >= 0 ? '+' : ''}${delta1})</span>
    </p>
    <p><strong>${match.player2}:</strong> ${score2} pkt${streak2}<br/>
       ELO: ${elo2Before} ‚Üí ${elo2Before + delta2}
       <span class="text-muted">(zmiana: ${delta2 >= 0 ? '+' : ''}${delta2})</span>
    </p>
    <hr/>
    <p>‚úÖ <strong>Zwyciƒôzca:</strong> ${winner}</p>
    <p class="text-muted" style="font-size:13px;">
      ‚ö°Ô∏è Bonus za przewagƒô punktowƒÖ: √ó${marginFactor.toFixed(2)}
    </p>
  `;

  const modal = new bootstrap.Modal(
    document.getElementById("matchConfirmModal")
  );
  modal.show();

  // ‚îÄ‚îÄ‚îÄ Obs≈Çuga klikniƒôcia ‚ÄûPotwierd≈∫‚Äù w modalu ‚îÄ‚îÄ‚îÄ
  document.getElementById("confirmMatchBtnFinal").onclick = async () => {
    modal.hide();

    // Zapisujemy wynik i potwierdzamy
    match.result = result;
    match.confirmed = true;

    // Aktualizacja streak√≥w
    updateStreak(match.player1, score1 > score2);
    updateStreak(match.player2, score2 > score1);

    // Aktualizacja ELO
    if (p1 && p2) updateElo(p1, p2, score1, score2);

    // Dodajemy do pe≈Çnej historii
    allMatches.push({ ...match, timestamp: new Date().toISOString() });

    // UI: zmiana przycisku i statusu
    const btn = document.getElementById(`confirmButton-${index}`);
    btn.classList.remove("btn-outline-success");
    btn.classList.add("btn-success");
    const rows = document
      .getElementById("matchesTable")
      .getElementsByTagName("tr");
    rows[index + 1].classList.add("confirmed");
    window.addResultToResultsTable(match);

    // ‚îÄ‚îÄ‚îÄ Aktualizacja statystyk i zapis ‚îÄ‚îÄ‚îÄ
    updateStats(match, stats, generalStats);
    await saveData(generalStats, allPlayers);
    await saveDraft();

    // ‚îÄ‚îÄ‚îÄ Od≈õwie≈ºenie widok√≥w ‚îÄ‚îÄ‚îÄ
    window.renderMatches();
    if (matches.every(m => m.confirmed)) {
      matches = [];
      generateMatches(); // kolejna seria
    }
    window.renderStats();

    // Reset kolor√≥w input√≥w
    input1.style.backgroundColor = "";
    input2.style.backgroundColor = "";
  };
}


// ======= ZAKO≈ÉCZENIE TURNIEJU =======
export async function endTournament() {
  // 1) Sprawdzenie, czy rozegrano choƒá jeden mecz
  const allConfirmedMatches = allMatches.filter(m => m.confirmed);
  if (allConfirmedMatches.length === 0) {
    alert("Nie mo≈ºna zako≈Ñczyƒá turnieju ‚Äì ≈ºaden mecz nie zosta≈Ç rozegrany.");
    return;
  }
  if (tournamentEnded) return;

  // 2) Oznaczamy zako≈Ñczenie
  tournamentEnded = true;
  window.tournamentEnded = true;

  // 3) Aktualizacja obecno≈õci (obecnosc++)
  allPlayers
    .filter(p => p.selected)
    .forEach(player => {
      const name = player.name;
      if (!generalStats[name]) {
        generalStats[name] = {
          wins: 0,
          losses: 0,
          pointsScored: 0,
          pointsConceded: 0,
          obecnosc: 0,
        };
      }
      generalStats[name].obecnosc = (generalStats[name].obecnosc || 0) + 1;
    });

  // 4) Zapis g≈Ç√≥wny do Firestore
  await saveData(generalStats, allPlayers);

  // 5) Od≈õwie≈ºenie widoku i blokada przycisk√≥w
  window.renderGeneralStats();
  document.getElementById("addPlayerBtn").disabled = true;
  document.getElementById("confirmPlayersBtn").disabled = true;
  document.getElementById("generateMatchesBtn").disabled = true;
  document.getElementById("numCourts").disabled = true;

  const endBtn = document.getElementById("endTournamentBtn");
  endBtn.disabled = true;
  endBtn.classList.remove("btn-danger");
  endBtn.classList.add("btn-secondary");

  alert("Turniej zosta≈Ç zako≈Ñczony. Nie mo≈ºna ju≈º generowaƒá meczy ani wpisywaƒá wynik√≥w.");

  // 6) Odblokuj zak≈Çadkƒô rozlicze≈Ñ
  document.getElementById("showPayoutBtn").style.display = "";

  // 7) Budowa archiwum z podzia≈Çem na serie
  const archive = {
    data: new Date().toISOString(),
    gracze: allPlayers.filter(p => p.selected).map(p => p.name),
    serie: [],
  };

  const serieMap = new Map();
  allMatches.forEach(match => {
    const key = `seria_${match.series ?? 1}`;
    if (!serieMap.has(key)) serieMap.set(key, []);
    serieMap.get(key).push({
      ...match,
      timestamp: match.timestamp || new Date().toISOString(),
    });
  });

  // 8) Zapis kolejnych serii jako osobne wpisy robocze
  for (const [seriaKey, serieMatches] of serieMap.entries()) {
    archive.serie.push({
      numer: seriaKey,
      mecze: serieMatches.map(m => ({
        gracz1: m.player1,
        gracz2: m.player2,
        runda: m.round ?? m.series,
        wynik:
          typeof m.result === "string" && m.result.trim() !== ""
            ? m.result
            : "-",
        timestamp: m.timestamp,
      })),
    });

    // Po ka≈ºdej serii czy≈õcimy bie≈ºƒÖce mecze/statystyki i robimy zapis roboczy
    matches = [];
    stats = {};
    window.matches = [];
    window.stats = {};
    await saveDraft();
  }
}


// ======= GENEROWANIE MECZ√ìW (AKTUALNA SERIA) =======
export function generateMatches() {
  // 1) Pobieramy nazwy zaznaczonych graczy
  const selectedNames = allPlayers
    .filter(p => p.selected)
    .map(p => p.name);

  // 2) Ile jest kort√≥w?
  const courtCount = parseInt(
    document.getElementById("numCourts").value,
    10
  ) || 1;

  // 3) Numer bie≈ºƒÖcej serii = ostatnia seria + 1
  const lastSeries = allMatches.at(-1)?.series || 0;
  const seriesNumber = lastSeries + 1;

  // 4) Generujemy mecze za pomocƒÖ pairing.js
  const newMatches = generateMatchesForSeries(
    selectedNames,
    courtCount,
    seriesNumber
  );

  // 5) Aktualizujemy tablice i globalne zmienne
  matches    = newMatches;
  allMatches = [...allMatches, ...newMatches];
  window.matches    = matches;
  window.allMatches = allMatches;

  // 6) Rysujemy mecze i chowamy panel startowy
  window.renderMatches();
  hideSetupControls();
  document.getElementById("endTournamentWrapper").style.display = "block";

  // 7) Roboczy zapis na Firebase
  saveDraft();
}



// ======= WCZYTANIE DANYCH Z FIREBASE =======
export async function loadDataFromFirebase() {
  const docRef = doc(db, "turniej", "stats");
  try {
    const docSnap = await getDoc(docRef);
    if (docSnap.exists()) {
      const data = docSnap.data();
      allPlayers = (data.allPlayers || []).map(p => ({
        ...p,
        elo: p.elo ?? 1000
      }));
      generalStats = data.generalStats || {};
      tournamentEnded = data.tournamentEnded || false;
      window.tournamentEnded = tournamentEnded;
      
      if (allPlayers.length > 0) {
        nextPlayerId = Math.max(...allPlayers.map(p => p.id)) + 1;
      }

      // ‚úÖ ZAPISZ DO window.* ‚Äì ≈ºeby initUI() mia≈Ç do nich dostƒôp
      // Najwa≈ºniejsze linie
      window.allPlayers = allPlayers;
      window.generalStats = generalStats;
      window.matches = matches;
      window.stats = stats;


      window.renderPlayersList?.();
      window.renderGeneralStats?.();
    } else {
      console.log("Brak dokumentu 'stats' w kolekcji 'turniej'");
    }
  } catch (error) {
    console.error("B≈ÇƒÖd odczytu danych z Firebase: ", error);
  }
  console.log("‚úÖ Dane z Firebase:", { allPlayers, generalStats });
  console.log("üéØ tournamentEnded z bazy:", tournamentEnded);

}



export function getCurrentSeriesNumber() {
  if (matches.length === 0) return 0;
  const allConfirmed = matches.every(m => m.confirmed);
  return allConfirmed ? matches[matches.length - 1].series || 0 : matches[0].series || 1;
}



function hideSetupControls() {
  ["setupPanel", "playersList", "generateMatchesBtn"].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.style.display = "none";
  });

  const nc = document.getElementById("numCourts")?.parentElement;
  if (nc) nc.style.display = "none";
}

 export async function resetTournamentData() {
  if (!confirm("Na pewno usunƒÖƒá wszystkie dane trwajƒÖcego turnieju?")) return;

 
  
  matches = [];
  stats = {};
  tournamentEnded = false;

  document.getElementById("matchesTable").innerHTML = "";
  document.getElementById("resultsTable").getElementsByTagName("tbody")[0].innerHTML = "";
  document.getElementById("statsTable").getElementsByTagName("tbody")[0].innerHTML = "";

  alert("Dane turnieju zosta≈Çy zresetowane.");
  window.location.href = window.location.href.split("?")[0];
  prepareForNewTournament();
  const playersRef = doc(window.db, "turniej", "stats");



}
export async function prepareForNewTournament() {
  console.log("üîÅ Przygotowanie nowego turnieju");

  tournamentEnded = false;
  window.tournamentEnded = false;

  matches = [];
  allMatches = [];
  stats = {};

  window.matches = [];
  window.allMatches = [];
  window.stats = {};
// Teraz czy≈õcimy zaznaczenie graczy,
  // bo faktycznie zaczynamy od nowa
  allPlayers.forEach(player => player.selected = false);
  window.renderPlayersList();
  // Oczy≈õƒá interfejs
  document.getElementById("matchesTable").innerHTML = "";
  document.getElementById("resultsTable").getElementsByTagName("tbody")[0].innerHTML = "";
  document.getElementById("statsTable").getElementsByTagName("tbody")[0].innerHTML = "";

  // Poka≈º ponownie panel wyboru graczy
  ["setupPanel", "playersList", "generateMatchesBtn"].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.style.display = "block";
  });

  const nc = document.getElementById("numCourts")?.parentElement;
  if (nc) nc.style.display = "block";

  const endWrapper = document.getElementById("endTournamentWrapper");
  if (endWrapper) endWrapper.style.display = "none";

  window.renderPlayersList?.();
  window.renderGeneralStats?.();
  const user = auth.currentUser;
if (user) {
  const playersRef = doc(window.db, "turniej", "stats");
  
}

}

// ======= AUTO-ZAPIS CO 10 SEKUND (je≈õli turniej trwa) =======
setInterval(async() => {
  const user = auth.currentUser;
  if (!user || window.tournamentEnded) return;


  const activeMatches = matches.filter(m => !m.confirmed);
  if (activeMatches.length === 0) return; // nic do zapisu

  await saveDraft();

  console.log("üïí Auto-zapis wykonany");
}, 10000); // co 10 sekund
